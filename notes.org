* Things we want to cover

** Theoretical side

*** Notion of greatest fixed point

*** Coinductive reasoning principle: based on Tarski's principle
    TODO : double check if that's the same thing as "Park's principle" or if there's a difference

*** Reasoning up-to
    Definition, sound closure, respectful class, yadi yada

*** Parameterized coinduction

*** Generalized parameterized coinduction

** Coq side

*** Reduction rules, frob

    Fix, cofix, match: governed by iota rules. For cofix, dual to the one of
    fix: a fix reduces when its arguments are known; a cofix reduces when it is
    patterned matched on.
    Intuitively: a cofix can always provide more constructors to the environment,
    to avoid diverging, we only reduce as long as the context knows what to do
    with these constructors.
    Hence the [frob] trick.

*** Subject reduction is broken

    CoInductive tick := Tick : tick -> tick.
    CoFixpoint loop := Tick loop.
    Definition etaeq : loop = loop :=
    match loop with
    | Tick t â‡’ eq_refl (Tick t) |
    end.
    Definition BOOM := Eval compute in (etaeq : loop = loop).
    https://www.xn--pdrot-bsa.fr/slides/rapido-06-15.pdf

    I don't think this compiles in the current version of Coq, I put a version that
    does in sts.v

*** Positive, negative

    The problem lies with using positive coinductive types. Conceptually inductive
    types are defined with constructors and coinductive types are defined with
    destructors, however both are defined using constructors when using positive
    coinductive types. This allows for dependent pattern matching on coinductive
    types, the cause of the issue above. Instead, if we only allow for negative
    coinductive types using records and primitive projections (which disallow pattern
    matching), we retain subject reduction.

*** Guardedness

    Oppositely to recursive ones, there is no decreasing argument in a co-recursive
    definition. To be admissible, a method of construction must provide at least one
    extra constructor of the infinite object for each iteration. A syntactical guard
    condition is imposed on co-recursive definitions in order to ensure this: each
    recursive call in the definition must be protected by at least one constructor,
    and only by constructors.

    "One cannot chain coinductive lemmas in proofs.
    Everything must be done in one go."

    Since this guardedness condition is syntactic, coinductive proofs are not
    properly compositional. If a proof uses another lemma in it, Coq must check that
    all corecursive calls are syntactically guarded, by checking the proof of the
    other lemma. This requires all coinductive lemmas you want to use to be made
    transparent (Defined instead of Qed).

*** paco

*** gpaco

** Examples

*** Finite automaton -> infinite properties

*** Infinite state machine -> infinite object

*** Streams

*** ITrees

*** Pi-calculus?

** Resources

*** Corecursion and coinduction: what they are and how they relate to recursion and induction
    https://pdfs.semanticscholar.org/41fb/876f6b35971173ef1808472350b51cf3afd1.pdf

*** A Tutorial on Co-induction and Functional Programming
    http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.8.7706&rep=rep1&type=pdf

*** An introduction to (co)algebra and (co)induction
    https://homepages.cwi.nl/~janr/papers/files-of-papers/2011_Jacobs_Rutten_new.pdf

*** Co-induction in relational semantics
    https://www.sciencedirect.com/science/article/pii/030439759190033X

*** On Streams and Coinduction
    https://homepages.cwi.nl/~janr/papers/files-of-papers/CRM.pdf

*** An Introduction to Coinduction (hritcu)
    https://prosecco.gforge.inria.fr/personal/hritcu/dyn/coind/CoindStart.html

*** Coinductive (Adam)
    http://adam.chlipala.net/cpdt/html/Coinductive.html#approx

*** Relevant git issues

    https://github.com/coq/coq/issues/6768
    https://github.com/coq/coq/pull/10764
    https://github.com/coq/coq/pull/7536
